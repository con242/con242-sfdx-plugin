"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MixedContentSourceAdapter = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const errors_1 = require("../../errors");
const path_2 = require("../../utils/path");
const sourceComponent_1 = require("../sourceComponent");
const baseSourceAdapter_1 = require("./baseSourceAdapter");
/**
 * Handles types with mixed content. Mixed content means there are one or more additional
 * file(s) associated with a component with any file extension. Even an entire folder
 * can be considered "the content".
 *
 * __Example Types__:
 *
 * StaticResources, Documents, Bundle Types
 *
 * __Example Structures__:
 *
 *```text
 * foos/
 * ├── myFoo/
 * |   ├── fooFolder/
 * |      ├── foofighters.x
 * |   ├── foo.y
 * |   ├── fooBar.z
 * ├── myFoo.ext-meta.xml
 * bars/
 * ├── myBar.xyz
 * ├── myBar.ext2-meta.xml
 *```
 */
class MixedContentSourceAdapter extends baseSourceAdapter_1.BaseSourceAdapter {
    getRootMetadataXmlPath(trigger) {
        if (this.ownFolder) {
            const componentRoot = this.trimPathToContent(trigger);
            return this.tree.find('metadataXml', (0, path_1.basename)(componentRoot), componentRoot);
        }
        return this.findMetadataFromContent(trigger);
    }
    populate(trigger, component) {
        let contentPath = this.trimPathToContent(trigger);
        if (contentPath === (component === null || component === void 0 ? void 0 : component.xml)) {
            contentPath = this.tree.find('content', (0, path_2.baseName)(contentPath), (0, path_1.dirname)(contentPath));
        }
        if (!this.tree.exists(contentPath)) {
            throw new errors_1.ExpectedSourceFilesError(this.type, trigger);
        }
        if (component) {
            component.content = contentPath;
        }
        else {
            component = new sourceComponent_1.SourceComponent({
                name: (0, path_2.baseName)(contentPath),
                type: this.type,
                content: contentPath,
            }, this.tree, this.forceIgnore);
        }
        return component;
    }
    /**
     * Trim a path up until the root of a component's content. If the content is a file,
     * the given path will be returned back. If the content is a folder, the path to that
     * folder will be returned. Intended to be used exclusively for MixedContent types.
     *
     * @param path Path to trim
     * @param type MetadataType to determine content for
     */
    trimPathToContent(path) {
        const pathParts = path.split(path_1.sep);
        const typeFolderIndex = pathParts.findIndex((part) => part === this.type.directoryName);
        const offset = this.type.inFolder ? 3 : 2;
        return pathParts.slice(0, typeFolderIndex + offset).join(path_1.sep);
    }
    /**
     * A utility for finding a component's root metadata xml from a path to a component's
     * content. "Content" can either be a single file or an entire directory. If the content
     * is a directory, the path can be files or other directories inside of it.
     *
     * @param path Path to content or a child of the content
     */
    findMetadataFromContent(path) {
        const rootContentPath = this.trimPathToContent(path);
        const rootTypeDirectory = (0, path_1.dirname)(rootContentPath);
        const contentFullName = (0, path_2.baseName)(rootContentPath);
        return this.tree.find('metadataXml', contentFullName, rootTypeDirectory);
    }
}
exports.MixedContentSourceAdapter = MixedContentSourceAdapter;
//# sourceMappingURL=mixedContentSourceAdapter.js.map