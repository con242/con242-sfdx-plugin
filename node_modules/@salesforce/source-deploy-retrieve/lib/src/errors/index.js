"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MissingJobIdError = exports.MetadataApiRetrieveError = exports.ComponentSetError = exports.ConversionError = exports.MetadataTransferError = exports.DeployError = exports.SourceClientError = exports.UnexpectedForceIgnore = exports.ExpectedSourceFilesError = exports.TypeInferenceError = exports.RegistryError = exports.LibraryError = void 0;
const i18n_1 = require("../i18n");
class LibraryError extends Error {
    constructor(messageKey, args) {
        super(i18n_1.nls.localize(messageKey, args));
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.LibraryError = LibraryError;
class RegistryError extends LibraryError {
    constructor(messageKey, args) {
        super(messageKey, args);
    }
}
exports.RegistryError = RegistryError;
class TypeInferenceError extends RegistryError {
    constructor(messageKey, args) {
        super(messageKey, args);
    }
}
exports.TypeInferenceError = TypeInferenceError;
class ExpectedSourceFilesError extends RegistryError {
    constructor(type, originalPath, messageKey = 'error_expected_source_files') {
        super(messageKey, [originalPath, type.name]);
    }
}
exports.ExpectedSourceFilesError = ExpectedSourceFilesError;
class UnexpectedForceIgnore extends RegistryError {
    constructor(messageKey, args) {
        super(messageKey, args);
    }
}
exports.UnexpectedForceIgnore = UnexpectedForceIgnore;
class SourceClientError extends LibraryError {
    constructor(messageKey, args) {
        super(messageKey, args);
    }
}
exports.SourceClientError = SourceClientError;
class DeployError extends SourceClientError {
    constructor(messageKey, args) {
        super(messageKey, args);
    }
}
exports.DeployError = DeployError;
class MetadataTransferError extends LibraryError {
    constructor(messageKey, args) {
        super(messageKey, args);
    }
}
exports.MetadataTransferError = MetadataTransferError;
/**
 * A wrapper for any errors thrown in the conversion pipeline
 */
class ConversionError extends LibraryError {
    constructor(originalError) {
        super('error_failed_convert', originalError.message);
        this.stack = originalError.stack;
    }
}
exports.ConversionError = ConversionError;
class ComponentSetError extends LibraryError {
    constructor(messageKey, args) {
        super(messageKey, args);
    }
}
exports.ComponentSetError = ComponentSetError;
class MetadataApiRetrieveError extends LibraryError {
    constructor(messageKey, args) {
        super(messageKey, args);
    }
}
exports.MetadataApiRetrieveError = MetadataApiRetrieveError;
class MissingJobIdError extends LibraryError {
    constructor(operation) {
        super('error_no_job_id', [operation]);
    }
}
exports.MissingJobIdError = MissingJobIdError;
//# sourceMappingURL=index.js.map