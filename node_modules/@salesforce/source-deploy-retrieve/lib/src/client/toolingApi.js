"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolingApi = exports.deployTypes = void 0;
const errors_1 = require("../errors");
const i18n_1 = require("../i18n");
const utils_1 = require("../utils");
const collections_1 = require("../collections");
const registry_1 = require("../registry");
const types_1 = require("./types");
const retrieveUtil_1 = require("./retrieveUtil");
const deployStrategies_1 = require("./deployStrategies");
const retrieveTypes = new Set([
    'ApexClass',
    'ApexTrigger',
    'ApexPage',
    'ApexComponent',
    'AuraDefinitionBundle',
    'LightningComponentBundle',
]);
exports.deployTypes = new Map([
    ['ApexClass', 'ApexClassMember'],
    ['ApexTrigger', 'ApexTriggerMember'],
    ['ApexPage', 'ApexPageMember'],
    ['ApexComponent', 'ApexComponentMember'],
    ['AuraDefinitionBundle', 'AuraDefinition'],
    ['LightningComponentBundle', 'LightningComponentResource'],
]);
class ToolingApi {
    constructor(connection, resolver, registry = new registry_1.RegistryAccess()) {
        this.connection = connection;
        this.resolver = resolver;
        this.registry = registry;
    }
    async retrieveWithPaths(options) {
        return this.retrieve({
            output: options.output,
            namespace: options.namespace,
            components: collections_1.ComponentSet.fromSource({ fsPaths: [options.paths[0]], registry: this.registry }),
        });
    }
    async retrieve(options) {
        let retrieveResult;
        if (options.components.size > 1) {
            const retrieveError = new Error();
            retrieveError.message = i18n_1.nls.localize('tapi_retrieve_component_limit_error');
            retrieveError.name = 'MetadataRetrieveLimit';
            throw retrieveError;
        }
        const mdComponent = options.components.getSourceComponents().first();
        if (!retrieveTypes.has(mdComponent.type.name)) {
            const retrieveError = new Error();
            retrieveError.message = i18n_1.nls.localize('beta_tapi_membertype_unsupported_error', mdComponent.type.name);
            retrieveError.name = 'MetadataTypeUnsupported';
            throw retrieveError;
        }
        try {
            const queryResult = (await this.connection.tooling.query((0, retrieveUtil_1.buildQuery)(mdComponent, options.namespace)));
            if (queryResult && queryResult.records.length === 0) {
                return {
                    status: types_1.RequestStatus.Failed,
                    success: false,
                    successes: [],
                    failures: [
                        {
                            component: {
                                fullName: mdComponent.fullName,
                                type: mdComponent.type,
                            },
                            message: i18n_1.nls.localize('error_md_not_present_in_org', mdComponent.fullName),
                        },
                    ],
                };
            }
            const saveFilesMap = (0, retrieveUtil_1.queryToFileMap)(queryResult, mdComponent, options.output);
            (0, utils_1.createFiles)(saveFilesMap);
            retrieveResult = {
                status: types_1.RequestStatus.Succeeded,
                success: true,
                successes: [{ component: mdComponent }],
                failures: [],
            };
        }
        catch (err) {
            throw new Error(i18n_1.nls.localize('error_in_tooling_retrieve', err));
        }
        return retrieveResult;
    }
    async deploy(components, options) {
        let mdComponent;
        if (Array.isArray(components)) {
            if (components.length > 1) {
                const deployError = new errors_1.SourceClientError('tapi_deploy_component_limit_error');
                throw deployError;
            }
            mdComponent = components[0];
        }
        else {
            mdComponent = components;
        }
        const metadataType = mdComponent.type.name;
        if (!exports.deployTypes.get(metadataType)) {
            throw new errors_1.SourceClientError('beta_tapi_membertype_unsupported_error', metadataType);
        }
        const deployStrategy = (0, deployStrategies_1.getDeployStrategy)(metadataType, this.connection);
        const namespace = options && options.namespace ? options.namespace : '';
        return deployStrategy.deploy(mdComponent, namespace);
    }
    async deployWithPaths(path, options) {
        return this.deploy(this.resolver.getComponentsFromPath(path), options);
    }
}
exports.ToolingApi = ToolingApi;
//# sourceMappingURL=toolingApi.js.map