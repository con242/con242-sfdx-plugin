"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseDeploy = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint @typescript-eslint/no-unsafe-assignment:0, @typescript-eslint/no-unsafe-call:0, @typescript-eslint/no-unsafe-member-access:0  */
const path_1 = require("path");
const graceful_fs_1 = require("graceful-fs");
const errors_1 = require("../../errors");
// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-var-requires,@typescript-eslint/no-unsafe-assignment
const DOMParser = require('xmldom-sfdx-encoding').DOMParser;
class BaseDeploy {
    constructor(connection) {
        this.connection = connection;
    }
    buildMetadataField(metadataContent) {
        try {
            const parser = new DOMParser();
            const document = parser.parseFromString(metadataContent, 'text/xml');
            const apiVersion = document.getElementsByTagName('apiVersion')[0].textContent;
            const statusNode = document.getElementsByTagName('status')[0];
            const packageNode = document.getElementsByTagName('packageVersions')[0];
            const descriptionNode = document.getElementsByTagName('description')[0];
            const labelNode = document.getElementsByTagName('label')[0];
            return {
                apiVersion,
                ...(statusNode ? { status: statusNode.textContent } : {}),
                ...(packageNode ? { packageVersions: packageNode.textContent } : {}),
                ...(descriptionNode ? { description: descriptionNode.textContent } : {}),
                ...(labelNode ? { label: labelNode.textContent } : {}),
            };
        }
        catch (e) {
            throw new errors_1.DeployError('error_parsing_metadata_file');
        }
    }
    // If bundle already exists then use Id and update existing
    // else, create a new bundle
    async upsertBundle(Id) {
        const metadataContent = (0, graceful_fs_1.readFileSync)(this.component.xml, 'utf8');
        const metadataField = this.buildMetadataField(metadataContent);
        let bundleResult;
        if (Id) {
            const bundleObject = { Id, Metadata: metadataField };
            bundleResult = (await this.connection.tooling.update(this.component.type.name, bundleObject));
        }
        else {
            const bundleObject = {
                FullName: this.component.fullName,
                Metadata: metadataField,
            };
            bundleResult = await this.toolingCreate(this.component.type.name, bundleObject);
        }
        if (!bundleResult.success) {
            throw new errors_1.DeployError('error_creating_metadata_type', this.component.type.name);
        }
        return bundleResult;
    }
    async toolingCreate(type, record) {
        return (await this.connection.tooling.create(type, record));
    }
    getFormattedPaths(filepath) {
        const pathParts = filepath.split(path_1.sep);
        const typeFolderIndex = pathParts.findIndex((part) => part === this.component.type.directoryName);
        return [
            pathParts.slice(typeFolderIndex).join(BaseDeploy.TOOLING_PATH_SEP),
            pathParts.slice(typeFolderIndex + 1).join(BaseDeploy.TOOLING_PATH_SEP),
        ];
    }
}
exports.BaseDeploy = BaseDeploy;
BaseDeploy.TOOLING_PATH_SEP = '/';
//# sourceMappingURL=baseDeploy.js.map